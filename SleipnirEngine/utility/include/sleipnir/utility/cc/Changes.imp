/*
* Copyright (C) 2019 by Godlike
* This code is licensed under the MIT license (MIT)
* (http://opensource.org/licenses/MIT)
*/

#ifndef SLEIPNIR_UTILITY_CC_CHANGES_IMP
#define SLEIPNIR_UTILITY_CC_CHANGES_IMP

#include <sleipnir/utility/cc/Changes.hpp>

namespace sleipnir
{
namespace utility
{
namespace cc
{

//! Changes::Instance

template<typename TMemento, typename TTimeUnit>
    bool Changes<TMemento, TTimeUnit>::Instance::IsEmpty() const
    {
        return m_add.empty() && m_modify.empty() && m_delete.empty();
    }

template<typename TMemento, typename TTimeUnit>
    bool Changes<TMemento, TTimeUnit>::Instance::operator<(Changes<TMemento, TTimeUnit>::Instance const& other) const
    {
        return m_priority < other.m_priority;
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Add(Changes<TMemento, TTimeUnit>::Snapshot entry)
    {
        m_add.push_back(entry);
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Modify(Changes<TMemento, TTimeUnit>::Snapshot entry, Changes<TMemento, TTimeUnit>::ModifyOperation operation)
    {
        m_modify.emplace_back(entry, operation);
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Delete(Changes<TMemento, TTimeUnit>::Snapshot entry)
    {
        m_delete.push_back(entry);
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Reset()
    {
        m_add.clear();
        m_modify.clear();
        m_delete.clear();
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Push(TTimeUnit timestamp)
    {
        assert(nullptr != m_pParent);

        m_pParent->Push(*this, timestamp);
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Export(Changes<TMemento, TTimeUnit>::AddCollection& adds
        , Changes<TMemento, TTimeUnit>::ModifyCollection& modifies
        , Changes<TMemento, TTimeUnit>::DeleteCollection& deletes
    )
    {
        adds.clear();
        modifies.clear();
        deletes.clear();

        m_add.swap(adds);
        m_modify.swap(modifies);
        m_delete.swap(deletes);
    }

template<typename TMemento, typename TTimeUnit>
    Changes<TMemento, TTimeUnit>::Instance::Instance(Changes<TMemento, TTimeUnit>* pParent, uint16_t priority)
        : m_pParent(pParent)
        , m_priority(priority)
    {
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Instance::Merge(Changes<TMemento, TTimeUnit>::Instance const& other)
    {
        m_add.insert(m_add.cend(), other.m_add.cbegin(), other.m_add.cend());
        m_modify.insert(m_modify.cend(), other.m_modify.cbegin(), other.m_modify.cend());
        m_delete.insert(m_delete.cend(), other.m_delete.cbegin(), other.m_delete.cend());
    }

// Changes::Integrator

template<typename TMemento, typename TTimeUnit> template<class TCollection>
    Changes<TMemento, TTimeUnit>::Integrator<TCollection>::Integrator(TCollection& collection)
    : m_collection(collection)
    {
    }

template<typename TMemento, typename TTimeUnit> template<class TCollection>
    void Changes<TMemento, TTimeUnit>::Integrator<TCollection>::Integrate(Changes<TMemento, TTimeUnit>::Instance& diff)
    {
        using Object = typename TCollection::Object;

        typename Changes<TMemento, TTimeUnit>::AddCollection adds;
        typename Changes<TMemento, TTimeUnit>::ModifyCollection modifies;
        typename Changes<TMemento, TTimeUnit>::DeleteCollection deletes;

        diff.Export(adds, modifies, deletes);

        for (auto const& _delete : deletes)
        {
            m_collection.Delete(_delete);
        }

        for (auto const& _add : adds)
        {
            m_collection.Spawn(_add);
        }

        for (auto const& _modify : modifies)
        {
            Object* pObj = m_collection.Get(_modify.first);

            if (nullptr != pObj)
            {
                (pObj->*(_modify.second))(_modify.first);
            }
        }
    }

template<typename TMemento, typename TTimeUnit>
    typename Changes<TMemento, TTimeUnit>::Instance Changes<TMemento, TTimeUnit>::Clone(uint16_t priority)
    {
        using Instance = Changes<TMemento, TTimeUnit>::Instance;

        return Instance(this, priority);
    }

template<typename TMemento, typename TTimeUnit>
    void Changes<TMemento, TTimeUnit>::Push(Changes<TMemento, TTimeUnit>::Instance& instance, TTimeUnit timestamp)
    {
        using Instance = Changes<TMemento, TTimeUnit>::Instance;

        Instance tmp(instance.m_pParent, instance.m_priority);
        std::swap(tmp, instance);

        {
            std::lock_guard<std::mutex> lock(m_hostMutex);

            m_pushes.emplace(tmp, timestamp);
        }
    }

template<typename TMemento, typename TTimeUnit>
    typename Changes<TMemento, TTimeUnit>::Instance Changes<TMemento, TTimeUnit>::Pull(TTimeUnit timestamp)
    {
        using Instance = Changes<TMemento, TTimeUnit>::Instance;

        std::priority_queue<Instance> pending;

        {
            std::lock_guard<std::mutex> lock(m_hostMutex);

            pending.swap(m_pushes);
        }

        Instance result(nullptr, 0);

        while (!pending.empty())
        {
            if (pending.top().timestamp <= timestamp)
            {
                result.Merge(pending.top().instance);
                pending.pop();
            }
            else
            {
                break;
            }
        }

        return result;
    }

template<typename TMemento, typename TTimeUnit>
    Changes<TMemento, TTimeUnit>::PushCommand::PushCommand(Instance& instance, TTimeUnit timestamp)
        : instance(instance)
        , timestamp(timestamp)
    {}

template<typename TMemento, typename TTimeUnit>
    bool Changes<TMemento, TTimeUnit>::PushCommand::operator<(PushCommand const& other) const
    {
        return timestamp != other.timestamp
            ? timestamp < other.timestamp
            : instance < other.instance
        ;
    }

}
}
}

#endif // SLEIPNIR_UTILITY_CC_CHANGES_IMP
